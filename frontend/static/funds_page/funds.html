{% extends 'base.html' %}
{% block title %}Funds{% endblock %}
{% set active_page = Funds %}
{% block content %}
<link rel="stylesheet" href="../static/funds_page/funds.css" type="text/css" />
<div class="row justify-content-left">
  <div class="col-md-7">
    <div class="graph-wrapper">
      <div id="treemap"></div>
    </div>
  </div>
  <div class="col-md-5 align-self-center">
    <div class="graph-wrapper donut-wrapper">
      <div id="donut"></div>
    </div>
  </div>
</div>
<div class="row justify-content-center">
  <div class="col-md-10">
    <div class="graph-wrapper">
      <div id="area"></div>
    </div>
  </div>
</div>
<div class="row justify-content-center">
  <div class="col-md-12">
    <div class="table-wrapper">
      <table id="fund-table" class="table display nowrap compact"
      data-order='[[ 0, "asc" ]]' data-page-length='25'>
        <thead class="thead-dark" border=0>
          {% for key in fund_data[0]  %}
          <th scope="col" class=""> {{key}} </td>
            {% endfor %}
        </thead>
        <tbody>
          {% for fund in fund_data %}
          <tr>
            {% for key in fund %}
              {% if key == "asset_class" %}
                <td contenteditable class="editable-cell">{{fund[key]}}</td>
              {% else %}
                <td nowrap> {{fund[key]}} </td>
              {% endif %}      
            {% endfor %}
          </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </div>
</div>
<script type="text/javascript">

  const data = {{ fund_data | tojson }};

  if(!data.length){
    console.log("HANDLE EMPTY")
    throw new Error("Stop script");
  }


  const data_headers = {{ fund_headers | tojson }}

  const build_treemap = () => {
    // set the dimensions and margins of the graph
    const margin = {top: 10, right: 10, bottom: 10, left: 10},
    width = 800 - margin.left - margin.right,
    height = 800 - margin.top - margin.bottom;

    // And a opacity scale
    const opacity = d3.scaleLinear()
      .domain([10, 30])
      .range([.5,1])

    // creating group 
    const groupByAssetClass = d3.group(data, d => d.asset_class)

    // append the svg object to the body of the page
    const svg = d3.select("#treemap")
    .append("svg")
    .attr("viewBox", `0 0 ${width} ${height}`)
    .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")")
    // Give the data to this cluster layout:
    const root = d3.hierarchy(groupByAssetClass).sum(function(d){ return d.weight}) // Here the size of each leave is given in the 'value' field in input data

    // Then d3.treemap computes the position of each element of the hierarchy
    d3.treemap()
    .size([width, height])
    .paddingInner(3)      // Padding between each rectangle
    .paddingOuter(15)
    .paddingRight(0)
      //.padding(20)
    (root)

    // div for on hover effect
    const tooltipdiv = d3.select("body").append("div")
     .attr("class", "tooltip")

    // use this information to add rectangles:
    svg
      .selectAll("rect")
      .data(root.leaves())
      .enter()
      .append("rect")
        .attr('x', function (d) { return d.x0; })
        .attr('y', function (d) { return d.y0; })
        .attr('width', function (d) { return d.x1 - d.x0; })
        .attr('height', function (d) { return d.y1 - d.y0; })
        .attr("class", "treemap-rect")
        .style("opacity", function(d){ return opacity(d.data.weight * 200)})
              //Makes the div appear on hover
      .on('mouseover', function(event, d) {
          d3.select(this).transition()
              .duration(200)
          
          tooltipdiv.html(`${d.data.asset}<br>${Math.round(d.data.market_value_sek)} SEK`)
               .style("left", (event.pageX + 10) + "px")
               .style("top", (event.pageY - 15) + "px");
          
          tooltipdiv.transition()
            .duration(50)
            .style("opacity", 1);
      })
      //Makes the div disappear
      .on('mouseout', function (d, i) {

            tooltipdiv.transition()
              .duration(50)
              .style("opacity", 0);
      })

    // Add the text labels
    svg
        .selectAll("text")
        .data(root.leaves())
        .enter()
        .append("text")
          .attr("x", function(d){ return d.x0+5})    // +10 to adjust position (more right)
          .attr("y", function(d){ return d.y0+20})    // +20 to adjust position (lower)
          .text(function(d){ return d.data.symbol })
          .attr("font-size", "15px")
          .attr("fill", "white")
    
    // add rectangle values
    svg
      .selectAll("vals")
      .data(root.leaves())
      .enter()
      .append("text")
        .attr("x", function(d){ return d.x0 + ((d.x1 - d.x0) / 2) - 12})    // +10 to adjust position (more right)
        .attr("y", function(d){ return d.y0 + ((d.y1 - d.y0) / 2) })    // +20 to adjust position (lower)
        .text(function(d){ return `${(d.data.weight * 100).toFixed(2)}%` })
        .attr("font-size", "11px")
        .attr("fill", "white")

    // Add group headings
    svg
      .selectAll("titles")
      .data(root.descendants().filter(function(d){return d.depth==1}))
      .enter()
      .append("text")
        .attr("x", function(d){ return d.x0 + 15})
        .attr("y", function(d){ return d.y0+8})
        .text(function(d){ 
          return `${d.data[0]} ${(d.value * 100).toFixed(2)}%` 
        })
        .attr("font-size", "15px")
        .attr("fill",  function(d){ return "grey" })// color(d.data.name)} )
        .append('svg:tspan')
        .attr('x', d.x0)
        .attr('dy', d.y0)
        .text(function(d) { `${(d.value * 100).toFixed(2)}%` })
    };

  const build_donut_chart = () => {

    // creating group 
    const groupByCurrency = d3.rollup(data,  v => d3.sum(v, (g) => {return g.market_value_sek } ), d => d.currency)
    console.log(groupByCurrency)
    // set the dimensions and margins of the graph
    const width = 450
        height = 450
        margin = 40

    // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
    const radius = Math.min(width, height) / 2 - margin

    // append the svg object to the div called 'my_dataviz'
    const svg = d3.select("#donut")
      .append("svg")
        .attr("width", width)
        .attr("height", height)
      .append("g")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    // set the color scale
    const color = d3.scaleOrdinal()
      .domain(["a", "b", "c", "d", "e", "f", "g", "h"])
      .range(d3.schemeDark2);

    // Compute the position of each group on the pie:
    const pie = d3.pie()
      .sort(null) // Do not sort group by size
      .value(function(d) {
        return d[1]; })

    const data_ready = pie(groupByCurrency.entries())
    // The arc generator
    const arc = d3.arc()
      .innerRadius(radius * 0.5)         // This is the size of the donut hole
      .outerRadius(radius * 0.8)

    // Another arc that won't be drawn. Just for labels positioning
    const outerArc = d3.arc()
      .innerRadius(radius * 0.9)
      .outerRadius(radius * 0.9)

    // div to show on hover 
    const tooltipdiv = d3.select("body").append("div")
     .attr("class", "tooltip")
    // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
    svg
      .selectAll('allSlices')
      .data(data_ready)
      .enter()
      .append('path')
      .attr('d', arc)
      .attr('fill', function(d){ return(color(d.data[0])) })
      .attr("stroke", "white")
      .style("stroke-width", "2px")
      .style("opacity", 0.8)
      .attr('transform', 'translate(0, 0)')
      //Makes the div appear on hover
      .on('mouseover', function(event, d) {
          d3.select(this).transition()
              .duration(200)
              .style('opacity', 0.7)
              .style('transform', 'scale(1.03)')
          tooltipdiv.html(`${Math.round(d.value)} SEK`)
               .style("left", (event.pageX + 10) + "px")
               .style("top", (event.pageY - 15) + "px");
          
          tooltipdiv.transition()
            .duration(200)
            .style("opacity", 1);
      })
      //Makes the div disappear
      .on('mouseout', function (d, i) {
          d3.select(this).transition()
              .duration('200')
              .style('opacity', 0.8)
              .style('transform', 'scale(1.0)')
          tooltipdiv.transition()
            .duration(200)
            .style("opacity", 0);
      })

    // Add the polylines between chart and labels:
    svg
      .selectAll('allPolylines')
      .data(data_ready)
      .enter()
      .append('polyline')
        .attr("stroke", "black")
        .style("fill", "none")
        .attr("stroke-width", 1)
        .attr('points', function(d) {
          const posA = arc.centroid(d) // line insertion in the slice
          const posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
          const posC = outerArc.centroid(d); // Label position = almost the same as posB
          const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
          posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left
          return [posA, posB, posC]
        })

    // Add the polylines between chart and labels:
    svg
      .selectAll('allLabels')
      .data(data_ready)
      .enter()
      .append('text')
        .text( function(d) { return d.data[0] } )
        .attr('transform', function(d) {
            const pos = outerArc.centroid(d);
            const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
            pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
            return 'translate(' + pos + ')';
        })
        .style('text-anchor', function(d) {
            const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
            return (midangle < Math.PI ? 'start' : 'end')
        });
      };

      const build_area_chart = () => {
        // create data
        const d_test = [{x: new Date("2021-01-01"), y: 20}, {x: new Date("2021-02-01"), y: 150}, {x: new Date("2021-03-01"), y: 100}, {x: new Date("2021-04-01"), y: 20}, {x: new Date("2021-05-01"), y: 130}]
        const d_test2 = [{x: new Date("2021-01-01"), y: 123}, {x: new Date("2021-02-01"), y: 31}, {x: new Date("2021-03-01"), y: 150}, {x: new Date("2021-04-01"), y: 20}, {x: new Date("2021-05-01"), y: 162}]

        // set the dimensions and margins of the graph
        const margin = {top: 10, right: 30, bottom: 30, left: 50},
            width = 800 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        const svg = d3.select("#area")
          .append("svg")
          .attr("viewBox", `0 0 ${width} ${height}`)
          .append("g")
          .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");
        
        // Add X axis --> it is a date format
        const x = d3.scaleTime()
          .domain(d3.extent(d_test, function(d) { return d.x; }))
          .range([ 0, width ]);

            svg.append("g")
              .attr("transform", "translate(0," + height + ")")
              .call(d3.axisBottom(x));

          // Add Y axis
          const y = d3.scaleLinear()
                .domain([0, d3.max(d_test, function(d) { return +d.y; })])
                .range([ height, 0 ]);
          
          svg.append("g")
            .call(d3.axisLeft(y))

          // Add the area
          svg.append("path")
            .datum(d_test)
            .attr("fill", "#cce5df")
            .attr("stroke", "#69b3a2")
            .attr("stroke-width", 1.5)
            .attr("d", d3.area()
              .x(function(d) { 
                return x(d.x) })
              .y0(y(0))
              .y1(function(d) { return y(d.y) })
              )
              .attr("opacity", '0.4')
        
              // Add the area
              svg.append("path")
            .datum(d_test2)
            .attr("fill", "blue")
            .attr("stroke", "#69b3a2")
            .attr("stroke-width", 1.5)
            .attr("d", d3.area()
              .x(function(d) { 
                return x(d.x) })
              .y0(y(0))
              .y1(function(d) { return y(d.y) })
              )
            .attr("opacity", '0.4')
        };

  $(document).ready( function() {

    $('body')
    .on('focus', '[contenteditable]', function() {
        const $this = $(this);
        $this.data('before', $this.html());
    })
    .on('keypress paste input', '[contenteditable]', function(event) {
        const $this = $(this);
        // On enter key
        if (event.keyCode === 10 || event.keyCode === 13) {
          event.preventDefault();
          console.log('enter key pressed')
          $this.blur();
        }
    })
    .on('submit', '[contenteditable]', function(event) {
      //const rowIndex = event.currentTarget.parentElement.rowIndex - 1
      //console.log(rowIndex)

      const updatedFundRow = Array.from(event.currentTarget.parentElement.cells).map(function(el){
        const content  = el.innerHTML.trim().replace("<br>", "" );
        const isNumber = parseFloat(content)
        return (isNumber) ?  isNumber : content   
      })
      console.log(updatedFtockRow, data_headers)
      let payload = {}
      for (let i = 0; i < data_headers.length; i++) {
        payload[data_headers[i]] = updatedFundRow[i]
      }
      console.log(payload)
      $.ajax({
        type: "PUT",
        url: '/portfolio/update',
        data: JSON.stringify(payload),
        success: function(d, status) {
          console.log(d, status)
        },
        dataType: 'application/json'
      });
    })
    .on('focusout', '[contenteditable]', function(){
      const $this = $(this);
      if ($this.data('before') !== $this.html()) {
          $this.data('before', $this.html());
          $this.trigger('submit');
      }
    })


    $('#fund-table').DataTable({
      "scrollX": true
    });


    build_treemap()

    build_area_chart()

    build_donut_chart()
  });
</script>
{% endblock %}
</html>
