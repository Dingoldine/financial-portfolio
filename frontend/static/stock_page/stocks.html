{% extends 'base.html' %}
{% block title %}Stocks{% endblock %}
{% set active_page = 'Stocks' %}
{% block content %}
<link rel="stylesheet" href="../static/stock_page/stocks.css" type="text/css" />
<div class="row justify-content-center">
  <div col-md-12>
    <h1>Stocks Overview</h1>
  </div>
</div>
<div class="row justify-content-left">
  <div class="col-md-7">
    <div class="graph-wrapper">
      <div id="treemap"></div>
    </div>
  </div>
  <div class="col-md-5 align-self-center">
    <div class="graph-wrapper donut-wrapper">
      <div id="donut"></div>
    <!-- <iframe id="cents-frame" src=https://www.acouplecents.com/stock-value-calculator height="750" width="500"></iframe> -->
    </div>
  </div>
</div>
<div class="row justify-content-center">
  <h3> Performance </h3><br/>
  <div class="graph-wrapper">
    <div id="area"></div>
  </div>
</div>
<div class="row justify-content-center">
  <div class="col-md-12">
    <div class="table-wrapper">
      <table id="stock-table" class="table display nowrap compact"
      data-order='[[ 0, "asc" ]]' data-page-length='25'>
        <thead class="thead-dark" border=0>
          {% for key in stock_data[0]  %}
          <th scope="col" class=""> {{key}} </td>
            {% endfor %}
          <th>Asset Class</th>
        </thead>
        <tbody>
          {% for stock in stock_data %}
          <tr>
            {% for key in stock %}
            <td nowrap> {{stock[key]}} </td>
            {% endfor %}
            <td contenteditable class="editable-cell"></td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </div>
</div>
<script type="text/javascript">

  const data = {{stock_data | tojson}};
  console.log(data)

  const build_svg = () => {
    // set the dimensions and margins of the graph
    const margin = {top: 10, right: 10, bottom: 10, left: 10},
    width = 845 - margin.left - margin.right,
    height = 845 - margin.top - margin.bottom;

    // And a opacity scale
    const opacity = d3.scaleLinear()
      .domain([10, 30])
      .range([.5,1])

    // creating group 
    const groupByCurrency = d3.group(data, d => d.currency)

    // append the svg object to the body of the page
    const svg = d3.select("#treemap")
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

    // Give the data to this cluster layout:
    const root = d3.hierarchy(groupByCurrency).sum(function(d){ return d.weight}) // Here the size of each leave is given in the 'value' field in input data

    // Then d3.treemap computes the position of each element of the hierarchy
    d3.treemap()
    .size([width, height])
    .paddingInner(3)      // Padding between each rectangle
    .paddingOuter(15)
    .paddingRight(0)
      //.padding(20)
    (root)

    // use this information to add rectangles:
    svg
      .selectAll("rect")
      .data(root.leaves())
      .enter()
      .append("rect")
        .attr('x', function (d) { return d.x0; })
        .attr('y', function (d) { return d.y0; })
        .attr('width', function (d) { return d.x1 - d.x0; })
        .attr('height', function (d) { return d.y1 - d.y0; })
        .attr("class", "hover-shadow")
        .style("stroke", "black")
        .style("fill", "slateblue")
        .style("opacity", function(d){ return opacity(d.data.weight * 200)})
        
    // and to add the text labels
    svg
        .selectAll("text")
        .data(root.leaves())
        .enter()
        .append("text")
          .attr("x", function(d){ return d.x0+5})    // +10 to adjust position (more right)
          .attr("y", function(d){ return d.y0+20})    // +20 to adjust position (lower)
          .text(function(d){ return d.data.symbol })
          .attr("font-size", "15px")
          .attr("fill", "white")
    
    // and to add the text labels
    svg
      .selectAll("vals")
      .data(root.leaves())
      .enter()
      .append("text")
        .attr("x", function(d){ return d.x0 + ((d.x1 - d.x0) / 2) - 12})    // +10 to adjust position (more right)
        .attr("y", function(d){ return d.y0 + ((d.y1 - d.y0) / 2) })    // +20 to adjust position (lower)
        .text(function(d){ return (d.data.weight * 100).toFixed(2) })
        .attr("font-size", "11px")
        .attr("fill", "white")

    // Add title for the 3 groups
    svg
      .selectAll("titles")
      .data(root.descendants().filter(function(d){return d.depth==1}))
      .enter()
      .append("text")
        .attr("x", function(d){ return d.x0 + 15})
        .attr("y", function(d){ return d.y0+8})
        .text(function(d){ 
          return d.data[0] })
        .attr("font-size", "19px")
        .attr("fill",  function(d){ return "grey" })// color(d.data.name)} )

    // Add title for the 3 groups
    svg
      .append("text")
        .attr("x", 300)
        .attr("y", 10)    // +20 to adjust position (lower)
        .text("Portfolio Composition")
        .attr("font-size", "25px")
        .attr("fill",  "grey" );
  
    };

  const build_donut_chart = () => {

    // creating group 
    const groupByCurrency = d3.rollup(data,  v => d3.sum(v, (g) => {return g.market_value_sek } ), d => d.currency)
    console.log(groupByCurrency)
    // set the dimensions and margins of the graph
    const width = 450
        height = 450
        margin = 40

    // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
    const radius = Math.min(width, height) / 2 - margin

    // append the svg object to the div called 'my_dataviz'
    const svg = d3.select("#donut")
      .append("svg")
        .attr("width", width)
        .attr("height", height)
      .append("g")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    // set the color scale
    const color = d3.scaleOrdinal()
      .domain(["a", "b", "c", "d", "e", "f", "g", "h"])
      .range(d3.schemeDark2);

    // Compute the position of each group on the pie:
    const pie = d3.pie()
      .sort(null) // Do not sort group by size
      .value(function(d) {
        return d[1]; })

    const data_ready = pie(groupByCurrency.entries())
    console.log(data_ready)
    // The arc generator
    const arc = d3.arc()
      .innerRadius(radius * 0.5)         // This is the size of the donut hole
      .outerRadius(radius * 0.8)

    // Another arc that won't be drawn. Just for labels positioning
    const outerArc = d3.arc()
      .innerRadius(radius * 0.9)
      .outerRadius(radius * 0.9)

    // div to show on hover 
    const tooltipdiv = d3.select("body").append("div")
     .attr("class", "tooltip-donut")
     .style("opacity", 0)
     .style("color", "black")
     .style("position", "absolute")
    // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
    svg
      .selectAll('allSlices')
      .data(data_ready)
      .enter()
      .append('path')
      .attr('d', arc)
      .attr('fill', function(d){ return(color(d.data[0])) })
      .attr("stroke", "white")
      .style("stroke-width", "2px")
      .style("opacity", 0.8)
      .attr('transform', 'translate(0, 0)')
      .on('mouseover', function(event, d) {
          d3.select(this).transition()
              .duration(200)
              .style('opacity', 0.7)
              .style('transform', 'scale(1.03)')
          //Makes the new div appear on hover:
          console.log(d)
          console.log(event.pageX)
          tooltipdiv.html(`${Math.round(d.value)} SEK`)
               .style("left", (event.pageX + 10) + "px")
               .style("top", (event.pageY - 15) + "px");
          
          tooltipdiv.transition()
            .duration(200)
            .style("opacity", 1);
      })
      .on('mouseout', function (d, i) {
          d3.select(this).transition()
              .duration('200')
              .style('opacity', 0.8)
              .style('transform', 'scale(1.0)')

          //Makes the new div appear on hover:
          tooltipdiv.transition()
            .duration(200)
            .style("opacity", 0);
      })

    // Add the polylines between chart and labels:
    svg
      .selectAll('allPolylines')
      .data(data_ready)
      .enter()
      .append('polyline')
        .attr("stroke", "black")
        .style("fill", "none")
        .attr("stroke-width", 1)
        .attr('points', function(d) {
          const posA = arc.centroid(d) // line insertion in the slice
          const posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
          const posC = outerArc.centroid(d); // Label position = almost the same as posB
          const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
          posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left
          return [posA, posB, posC]
        })

    // Add the polylines between chart and labels:
    svg
      .selectAll('allLabels')
      .data(data_ready)
      .enter()
      .append('text')
        .text( function(d) { return d.data[0] } )
        .attr('transform', function(d) {
            const pos = outerArc.centroid(d);
            const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
            pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
            return 'translate(' + pos + ')';
        })
        .style('text-anchor', function(d) {
            const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
            return (midangle < Math.PI ? 'start' : 'end')
        });
      };

      const build_area_chart = () => {
        // create data
        const d_test = [{x: new Date("2021-01-01"), y: 20}, {x: new Date("2021-02-01"), y: 150}, {x: new Date("2021-03-01"), y: 100}, {x: new Date("2021-04-01"), y: 20}, {x: new Date("2021-05-01"), y: 130}]
        const d_test2 = [{x: new Date("2021-01-01"), y: 123}, {x: new Date("2021-02-01"), y: 31}, {x: new Date("2021-03-01"), y: 150}, {x: new Date("2021-04-01"), y: 20}, {x: new Date("2021-05-01"), y: 162}]

        // set the dimensions and margins of the graph
        const margin = {top: 10, right: 30, bottom: 30, left: 50},
            width = 800 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        const svg = d3.select("#area")
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");
        
        // Add X axis --> it is a date format
        const x = d3.scaleTime()
          .domain(d3.extent(d_test, function(d) { return d.x; }))
          .range([ 0, width ]);

            svg.append("g")
              .attr("transform", "translate(0," + height + ")")
              .call(d3.axisBottom(x));

          // Add Y axis
          const y = d3.scaleLinear()
                .domain([0, d3.max(d_test, function(d) { return +d.y; })])
                .range([ height, 0 ]);
          
          svg.append("g")
            .call(d3.axisLeft(y))

          // Add the area
          svg.append("path")
            .datum(d_test)
            .attr("fill", "#cce5df")
            .attr("stroke", "#69b3a2")
            .attr("stroke-width", 1.5)
            .attr("d", d3.area()
              .x(function(d) { 
                return x(d.x) })
              .y0(y(0))
              .y1(function(d) { return y(d.y) })
              )
              .attr("opacity", '0.4')
        
              // Add the area
              svg.append("path")
            .datum(d_test2)
            .attr("fill", "blue")
            .attr("stroke", "#69b3a2")
            .attr("stroke-width", 1.5)
            .attr("d", d3.area()
              .x(function(d) { 
                return x(d.x) })
              .y0(y(0))
              .y1(function(d) { return y(d.y) })
              )
            .attr("opacity", '0.4')
        };

  $(document).ready( function() {
    
    const editable_cells = document.getElementsByClassName("editable-cell") 
    Array.from(editable_cells)
    .forEach(element => {
      element.addEventListener("submit", function() {
        console.log("submit event fired");
      }, false);
    });

    $('body')
    .on('focus', '[contenteditable]', function() {
        const $this = $(this);
        $this.data('before', $this.html());
    })
    .on('keypress paste input', '[contenteditable]', function(event) {
        const $this = $(this);
        // On enter key
        if (event.keyCode === 10 || event.keyCode === 13) {
          event.preventDefault();
          console.log('enter key pressed')
          $this.blur();
        }
    })
    .on('submit', '[contenteditable]', function(event) {

      const updatedStock = Array.from(event.currentTarget.parentElement.cells).map(function(el){
        return el.innerHTML.trim();
      })
      $.ajax({
        type: "PUT",
        url: '/stock/update',
        data: JSON.stringify(updatedStock),
        success: function(d, status) {
          console.log(d, status)
        },
        dataType: 'application/json'
      });
    })
    .on('focusout', '[contenteditable]', function(){
      const $this = $(this);
      if ($this.data('before') !== $this.html()) {
          $this.data('before', $this.html());
          $this.trigger('submit');
      }
    })


    $('#stock-table').DataTable({
      "scrollX": true
    });


    build_svg()

    build_area_chart()

    build_donut_chart()
  });
</script>
{% endblock %}
</html>